\section{Технологическая часть}

В данном разделе будет обоснован выбор средств программной реализации предлагаемого метода, описан формат входных и выходных данных. 
Разработано программное обеспечение, реализующее представленный метод, и выполнено его тестирование.

\subsection{Выбор средств разработки}

\subsubsection{Выбор платформы}
По результатам анализа только исследуемые методы отображения интерфейса нативной мобильной разработки не обладают функцией горячей перезагрузки. 
В связи с чем в качестве платформы разработки для реализации предлагаемого метода выбрана операционная система iOS.

\subsubsection{Выбор языка программирования}
Выбран язык Swift, поскольку он является основным используемым в нативной разработке iOS.

\subsubsection{Выбор среды разработки и сборка программного обеспечения}
Среда разработки --- XCode, поскольку является интегрированной средой разработки программного обеспечения для платформ macOS, iOS, watchOS и tvOS, разработанной корпорацией Apple, а также предоставляет возможность запуска разрабатываемого программного обеспечения на симуляторах устройств. 
Используется версия XCode 15.3, являющаяся актуальной на момент написания дипломной работы.
Запуск разрабатываемого программного обеспечения происходит на симуляторе устройства iPhone 15 Pro Max, версия iOS --- 17.4 (также является актуальной на момент написания дипломной работы).

\subsubsection{Используемые расширения}
Для создания представлений используется библиотека UIKit, содержащая полный набор базовых UI--элементов, а также механизмы размещения их на экране. 

\subsubsection{Выбор методов и средств тестирования}
Разработанное программное обеспечение должно корректно отображать задаваемые UI--элементы.
Для этого необходимо провести snapshot--тесты --- тесты, которые делают эталонный скриншот экрана и сравнивают с актуальным скриншотом, который получается во время прогона тестов.
Для выполнения тестирования будет использована библиотека SnapshotTesting, предоставляющая весь необходимый для созрания snapshot--тестов функционал.

\subsection{Формат входных и выходных данных}
Входные данные для разрабатываемого метода:

\begin{itemize}[label=---]
	\item пользовательский интерфейс;
	\item событие, инициализирующее изменения интерфейса;
	\item XML--файл, организованный специальным образом.
\end{itemize}

Выходные данные для разрабатываемого метода:

\begin{itemize}[label=---]
	\item пользовательский интерфейс, измененный во время выполнения программы.
\end{itemize}

\subsection{Детали реализации предлагаемого метода}

В листинге 2 представлен класс, обеспечивающий перезагрузку по время выполнения. 

\begin{lstlisting}[caption={Класс, обеспечивающий перезагрузку по время выполнения}]

class ReloadManager {
    private static var observersWeak = [ObserverWeak]()

    private struct ObserverWeak {
        weak var observer: LayoutInTimeViewController?
    }

    static var observers: [LayoutInTimeViewController] {
        return observersWeak.compactMap { $0.observer }
    }

    static func addObserver(_ observer: LayoutInTimeViewController) {
        var alreadyRegistered = false
        observersWeak = observersWeak.filter {
            guard let o = $0.observer else { return false }
            if o === observer { alreadyRegistered = true }
            return true
        }
        if alreadyRegistered {
            return
        }
        observersWeak.append(ObserverWeak(observer: observer))

        #if arch(arm64) || arch(x86_64)

            if !UIResponder.handlerInstalled {
                overrideMethod(#selector(getter: UIResponder.keyCommands),
                               of: UIResponder.self,
                               with: #selector(UIResponder.layoutItTimeKeyCommands)
                )
                UIResponder.handlerInstalled = true
            }

        #endif
    }

    static func reload() {
        for observer in observers {
            observer.reload()
        }
    }
}
\end{lstlisting}

Реализации класса использует функцию, представленную в листинге 3, которая определяет список событию, по свершению которых происходит перезагрузка, а также метод, представленный в листинге 4, переопределяющий функцию обработки нажатия горящих клавиш. 

\begin{lstlisting}[caption={Функция определения списка событий, по свершению которых происходит перезагрузка}]
#if arch(arm64) || arch(x86_64)
    private extension UIResponder {
        static var handlerInstalled = false

        @objc func layoutItTimeKeyCommands() -> [UIKeyCommand]? {

            return (layoutItTimeKeyCommands() ?? []) + [
                UIKeyCommand(
                    input: "t",
                    modifierFlags: .command,
                    action: #selector(reloadInTime)
                ),
            ]
        }

        @objc private func reloadInTime() {
            ReloadManager.reload()
        }
    }
#endif
\end{lstlisting}

\begin{lstlisting}[caption={Класс, обеспечивающий перезагрузку по время выполнения}]
func overrideMethod(_ selectorA: Selector, of sourceClass: AnyClass, with selectorB: Selector) {
    let newMethod = class_getInstanceMethod(sourceClass, selectorB)!
    let oldMethod = class_getInstanceMethod(sourceClass, selectorA)!
    let inheritedImplementation = class_getInstanceMethod(class_getSuperclass(sourceClass), selectorA)
        .map(method_getImplementation)
    if method_getImplementation(oldMethod) == inheritedImplementation {
        let types = method_getTypeEncoding(oldMethod)
        class_addMethod(sourceClass, selectorA, method_getImplementation(newMethod), types)
        return
    }
    method_exchangeImplementations(oldMethod, newMethod)
}
\end{lstlisting}

Для того, чтобы добавить экран ---  контроллер --- в список обновляемых элементов, необходимо в методе ViewDidLoad его жизненного цикла добавить вызов функции addObserver класса перезагрузки ReloadManager. 
Вызов представлен в листинге 5.


\begin{lstlisting}[caption={Класс, обеспечивающий перезагрузку по время выполнения}]
ReloadManager.addObserver(self)
\end{lstlisting}

В листинге 6 представлены перечисления и структуры, определяющие список базовых UI--элементов, их свойства и атрибуты.

\begin{lstlisting}[caption={Перечисления и структуры, определяющие список базовых UI--элементов, их свойства и атрибуты}]
enum ComponentType {
    case uiView
    case uiLabel
    case uiButton

    var startTag: String {
        switch self {
        case .uiView:
            return "UIView"
        case .uiLabel:
            return "UILabel"
        case .uiButton:
            return "UIButton"
        }
    }

    var endTag: String {
        switch self {
        case .uiView:
            return "/UIView"
        case .uiLabel:
            return "/UILabel"
        case .uiButton:
            return "/UIButton"
        }
    }
}

struct Anchors {
    public var topAnchorConstant: CGFloat?
    public var bottomAnchorConstant: CGFloat?
    public var leftAnchorConstant: CGFloat?
    public var rightAnchorConstant: CGFloat?
    public var height: CGFloat?
    public var width: CGFloat?
}

enum ComponentPropertyType {
    case width
    case height
    case topAnchor
    case bottomAnchor
    case leftAnchor
    case rightAnchor
    case backgroundColor
    case textAlignment
    case text

    var value: String {
        switch self {
        case .width:
            "width"
        case .height:
            "height"
        case .topAnchor:
            "topAnchor"
        case .bottomAnchor:
            "bottomAnchor"
        case .leftAnchor:
            "leftAnchor"
        case .rightAnchor:
            "rightAnchor"
        case .backgroundColor:
            "backgroundColor"
        case .textAlignment:
            "textAlignment"
        case .text:
            "text"
        }
    }
}
\end{lstlisting}

В листинге 7 представлены функции класса, преобразующего содержимое XML--файла в UI--элементы.

\begin{lstlisting}[caption={Функция определения списка событий, по свершению которых происходит перезагрузка}]
class LayoutInTime {
    public func createLayout(rootView: UIView, from xml: String) {
        guard let clearContent = parseXMLElements(xmlContent: xml) else {
            return
        }
        let separatedClearContent = clearContent.components(separatedBy: "\n")
        let joinedClearContent = separatedClearContent.joined(separator: "=")
        let components = joinedClearContent.components(separatedBy: "=")

        print(components)
        _ = createView(rootView: rootView, from: components)
    }

    private func createView(rootView: UIView, from components: [String]) -> Int {
        var i = 0
        var finalTagIndex = 0
        while i < components.count {
            switch components[i] {
            case ComponentType.uiView.startTag:
                var j = i + 1
                var uiView = UIView().autolayout()
                var anchors = Anchors()
                while components[j] != ComponentType.uiView.endTag {
                    switch components[j] {
                    case ComponentType.uiView.startTag,
                        ComponentType.uiLabel.startTag,
                        ComponentType.uiButton.startTag:
                        j += createView(rootView: uiView, from: Array(components[j..<components.count]))

                    case ComponentPropertyType.width.value:
                        incrementIndex(index: &j)
                        anchors.width = setWidthHeight(property: components[j], isHeight: false)
                    case ComponentPropertyType.height.value:
                        incrementIndex(index: &j)
                        anchors.height = setWidthHeight(property: components[j], isHeight: true)

                    case ComponentPropertyType.topAnchor.value:
                        incrementIndex(index: &j)
                        anchors.topAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.bottomAnchor.value:
                        incrementIndex(index: &j)
                        anchors.bottomAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.leftAnchor.value:
                        incrementIndex(index: &j)
                        anchors.leftAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.rightAnchor.value:
                        incrementIndex(index: &j)
                        anchors.rightAnchorConstant = Double(components[j]) ?? 0.0

                    case ComponentPropertyType.backgroundColor.value:
                        incrementIndex(index: &j)
                        uiView = setBackgroundColor(component: uiView, property: components[j])

                    default:
                        continue
                    }
                    incrementIndex(index: &j)
                }
                finalTagIndex = j
                rootView.addSubview(uiView)
                setAnchors(rootView: rootView, childView: uiView, anchors: anchors)
                incrementIndexByIndex(indexI: &i, by: j)

            case ComponentType.uiLabel.startTag:
                var j = i + 1
                var uiLabel = UILabel().autolayout()
                var anchors = Anchors()
                while components[j] != ComponentType.uiLabel.endTag {
                    print(components[j])
                    switch components[j] {
                    case ComponentType.uiView.startTag,
                        ComponentType.uiLabel.startTag,
                        ComponentType.uiButton.startTag:
                        j += createView(rootView: uiLabel, from: Array(components[j..<components.count]))

                    case ComponentPropertyType.width.value:
                        incrementIndex(index: &j)
                        anchors.width = setWidthHeight(property: components[j], isHeight: false)
                    case ComponentPropertyType.height.value:
                        incrementIndex(index: &j)
                        anchors.height = setWidthHeight(property: components[j], isHeight: true)

                    case ComponentPropertyType.topAnchor.value:
                        incrementIndex(index: &j)
                        anchors.topAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.bottomAnchor.value:
                        incrementIndex(index: &j)
                        anchors.bottomAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.leftAnchor.value:
                        incrementIndex(index: &j)
                        anchors.leftAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.rightAnchor.value:
                        incrementIndex(index: &j)
                        anchors.rightAnchorConstant = Double(components[j]) ?? 0.0

                    case ComponentPropertyType.backgroundColor.value:
                        incrementIndex(index: &j)
                        uiLabel = setBackgroundColor(component: uiLabel, property: components[j]) as! UILabel

                    case ComponentPropertyType.textAlignment.value:
                        incrementIndex(index: &j)
                        setTextAligment(component: &uiLabel, property: components[j])
                    case ComponentPropertyType.text.value:
                        incrementIndex(index: &j)
                        uiLabel.text = components[j]

                    default:
                        continue
                    }
                    incrementIndex(index: &j)
                }
                finalTagIndex = j
                rootView.addSubview(uiLabel)
                setAnchors(rootView: rootView, childView: uiLabel, anchors: anchors)
                incrementIndexByIndex(indexI: &i, by: j)

            case ComponentType.uiButton.startTag:
                var j = i + 1
                var uiButton = UIButton().autolayout()
                var anchors = Anchors()
                while components[j] != ComponentType.uiButton.endTag {
                    switch components[j] {
                    case ComponentType.uiView.startTag,
                        ComponentType.uiLabel.startTag,
                        ComponentType.uiButton.startTag:
                        j += createView(rootView: uiButton, from: Array(components[j..<components.count]))

                    case ComponentPropertyType.width.value:
                        incrementIndex(index: &j)
                        anchors.width = setWidthHeight(property: components[j], isHeight: false)
                    case ComponentPropertyType.height.value:
                        incrementIndex(index: &j)
                        anchors.height = setWidthHeight(property: components[j], isHeight: true)

                    case ComponentPropertyType.topAnchor.value:
                        incrementIndex(index: &j)
                        anchors.topAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.bottomAnchor.value:
                        incrementIndex(index: &j)
                        anchors.bottomAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.leftAnchor.value:
                        incrementIndex(index: &j)
                        anchors.leftAnchorConstant = Double(components[j]) ?? 0.0
                    case ComponentPropertyType.rightAnchor.value:
                        incrementIndex(index: &j)
                        anchors.rightAnchorConstant = Double(components[j]) ?? 0.0

                    case ComponentPropertyType.backgroundColor.value:
                        incrementIndex(index: &j)
                        uiButton = setBackgroundColor(component: uiButton, property: components[j]) as! UIButton

                    default:
                        continue
                    }
                    incrementIndex(index: &j)
                }
                finalTagIndex = j
                rootView.addSubview(uiButton)
                setAnchors(rootView: rootView, childView: uiButton, anchors: anchors)
                incrementIndexByIndex(indexI: &i, by: j)
            default:
                incrementIndex(index: &i)
            }
        }
        return finalTagIndex
    }

    private func incrementIndex(index: inout Int) {
        index += 1
    }

    private func incrementIndexByIndex(indexI: inout Int, by indexJ: Int) {
        indexI = indexJ + 1
    }

    private func createBaseView() -> UIView {
        UIView(frame: CGRect(
            x: 0,
            y: 0,
            width: UIScreen.main.bounds.width,
            height: UIScreen.main.bounds.height)
        )
    }
}

extension LayoutInTime {
    private func setTextAligment(component: inout UILabel, property: String) {
        switch property {
        case "left":
            component.textAlignment = NSTextAlignment(rawValue: 0)!
        case "center":
            component.textAlignment = NSTextAlignment(rawValue: 1)!
        case "right":
            component.textAlignment = NSTextAlignment(rawValue: 2)!
        default:
            break
        }
    }

    private func setBackgroundColor(component: UIView, property: String) -> UIView {
        switch property {
        case "white":
            component.backgroundColor = .white
        case "black":
            component.backgroundColor = .black
        case "green":
            component.backgroundColor = .green
        case "red":
            component.backgroundColor = .red
        case "blue":
            component.backgroundColor = .blue
        case "brown":
            component.backgroundColor = .brown
        case "cyan":
            component.backgroundColor = .cyan
        case "darkGray":
            component.backgroundColor = .darkGray
        case "gray":
            component.backgroundColor = .gray
        case "systemPink":
            component.backgroundColor = .systemPink
        case "yellow":
            component.backgroundColor = .yellow
        case "purple":
            component.backgroundColor = .purple
        case "orange":
            component.backgroundColor = .orange
        default:
            break
        }

        return component
    }

    private func setWidthHeight(property: String, isHeight: Bool) -> CGFloat {
        if property.contains("%") {
            return CGFloat(Double(
                property.replacingOccurrences(of: "%", with: "")
            ) ?? 0) / 100.0 * (isHeight ? UIScreen.main.bounds.height : UIScreen.main.bounds.width)
        }
        return CGFloat(Double(property) ?? 0)
    }

    private func setAnchors(rootView: UIView, childView: UIView, anchors: Anchors) {
        if let topAnchorConstant = anchors.topAnchorConstant {
            NSLayoutConstraint.activate([
                childView.topAnchor.constraint(equalTo: rootView.topAnchor, constant: topAnchorConstant)
            ])
        }
        if let leftAnchorConstant = anchors.leftAnchorConstant {
            NSLayoutConstraint.activate([
                childView.leftAnchor.constraint(equalTo: rootView.leftAnchor, constant: leftAnchorConstant)
            ])
        }
        if let bottomAnchorConstant = anchors.bottomAnchorConstant {
            NSLayoutConstraint.activate([
                childView.bottomAnchor.constraint(equalTo: rootView.bottomAnchor, constant: bottomAnchorConstant)
            ])
        }
        if let rightAnchorConstant = anchors.rightAnchorConstant {
            NSLayoutConstraint.activate([
                childView.rightAnchor.constraint(equalTo: rootView.rightAnchor, constant: rightAnchorConstant)
            ])
        }
        if let height = anchors.height {
            NSLayoutConstraint.activate([
                childView.heightAnchor.constraint(equalToConstant: height)
            ])
        }
        if let width = anchors.width {
            NSLayoutConstraint.activate([
                childView.widthAnchor.constraint(equalToConstant: width)
            ])
        }
    }
}
\end{lstlisting}

\subsection*{Вывод}

В данном разделе был обоснован выбор средств программной реализации предлагаемого метода, описан формат входных и выходных данных, разработано программное обеспечение, реализующее представленный метод, и выполнено его тестирование.

\pagebreak